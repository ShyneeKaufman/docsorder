<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8">
  <title>Формування опису документів</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 0; height: 100vh; display: flex; flex-direction: column; }
    .container-wrapper { flex: 1; display: flex; overflow: hidden; }
    .container { display: flex; flex-grow: 1; overflow: hidden; }
    .table-container, .list-container { flex: 1; min-height: 400px; border: 1px dashed #aaa; padding: 10px; overflow-y: auto; resize: horizontal; min-width: 200px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; table-layout: auto; }
    th, td { border: 1px solid #000; padding: 8px; text-align: center; }
    th { background-color: #f2f2f2; }
    .draggable-item { padding: 8px; border: 1px solid #ccc; background: #fafafa; margin-bottom: 5px; cursor: grab; display: flex; justify-content: space-between; align-items: center; }
    .draggable-item:active { cursor: grabbing; }
    .delete-btn, .edit-btn { background-color: red; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 4px; margin-left: 5px; }
    .edit-btn { background-color: orange; }
    .droppable-hover { background-color: #e0ffe0; }
    tr.dragging { opacity: 0.5; }
    .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); }
    .modal-content { background-color: #fefefe; margin: 15% auto; padding: 20px; border: 1px solid #888; width: 80%; max-width: 500px; }
    .close { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }
    .close:hover { color: black; }
    .replace-panel, .date-replace-panel { margin-top: 20px; padding: 10px; border: 1px solid #ddd; background: #f9f9f9; }
    #searchDoc { margin-bottom: 10px; }
    .export-panel { margin-top: 20px; padding: 10px; border: 1px solid #ddd; background: #f9f9f9; }
    .export-format { margin-top: 10px; }
    textarea { width: 100%; height: 100px; margin-top: 10px; }
  </style>
</head>
<body>
  <div class="container-wrapper">
    <div class="container">
      <div class="list-container" ondragover="event.preventDefault()" ondrop="handleRemove(event)">
        <h3>Документи</h3>
        <input type="text" id="searchDoc" placeholder="Пошук за назвою документу" oninput="searchDocuments()" />
        <div id="docList"></div>
      </div>
      <div class="table-container" ondragover="event.preventDefault()" ondrop="handleDrop(event)">
        <h2>Опис документів</h2>
        <div class="replace-panel">
          <label>Замінити <input type="text" id="replaceValueFrom" placeholder="Наприклад: ВВОД"> на: 
            <input type="text" id="replaceValueTo" placeholder="Наприклад: ВВОД2"></label>
          <button onclick="applyReplace()">Застосувати</button>
        </div>
        <div class="date-replace-panel">
          <label>Замінити всі дати на: <input type="date" id="replaceDateValue"></label>
          <button onclick="applyDateReplace()">Застосувати дати</button>
        </div>
        <table id="docTable">
          <thead>
            <tr>
              <th>№ п/п</th>
              <th>Назва документу</th>
              <th>Дата включення</th>
              <th style="min-width: 100px">К-ть аркушів</th>
              <th>Примітка</th>
              <th>Дія</th>
            </tr>
          </thead>
          <tbody id="docBody"></tbody>
        </table>
        <br />
        <button onclick="copyTable()">Копіювати таблицю</button>
        <button onclick="copyTableHtmlToClipboard()">Копіювати як HTML</button>
        <div class="export-panel">
          <h3>Експорт таблиці</h3>
          <div class="export-format">
            <label><input type="radio" name="exportFormat" value="txt" checked> TXT (текстовий)</label>
            <label><input type="radio" name="exportFormat" value="csv"> CSV</label>
            <label><input type="radio" name="exportFormat" value="custom"> Власний формат</label>
          </div>
          <textarea id="customFormat" placeholder="Введіть свій шаблон для експорту. Використовуйте {index}, {name}, {date}, {sheets}, {note} для підстановки значень. Наприклад: {index}. {name} від {date}">{index}.\n{name}\n{date}\n{sheets}\n\n\n</textarea>
          <button onclick="exportTable()">Експортувати у файл</button>
        </div>
      </div>
    </div>
  </div>

  <div class="settings">
    <h3>Налаштування документів</h3>
    <h4>Додати новий документ</h4>
    <input type="text" id="newDoc" placeholder="Назва нового документу" />
    <button onclick="addNewDocument()">Додати</button>
  </div>

  <!-- Модальное окно для редактирования -->
  <div id="editModal" class="modal">
    <div class="modal-content">
      <span class="close" onclick="closeModal()">&times;</span>
      <h3>Редагувати документ</h3>
      <input type="text" id="editDocName" style="width: 100%; padding: 8px; margin-bottom: 10px;">
      <button onclick="saveEditedDocument()">Зберегти</button>
    </div>
  </div>

  <script>
    let uniqueDocuments = JSON.parse(localStorage.getItem('documents')) || [
      "Заява про надання соціальних послуг ХХХ",
      "Акт оцінки потреб сім’ї ХХХ",
      "Висновок оцінки потреб сім’ї ХХХ",
      "Копія свідоцтва про народження дитини ХХХ",
      "Копія картки платника податків ХХХ",
      "Копія паспорту ХХХ",
      "Копія карти платника податків YYY",
      "Копія паспорту YYY",
      "Декларація про доходи та майновий стан особи, яка потребує надання соціальних послуг ХХХ",
      "Рішення про надання соціальних послуг",
      "Рішення про припинення надання соціальних послуг",
      "Повідомлення про сім’ю яка перебуває в складних життєвих обставинах №425/01-17",
      "Копія свідоцтва про народження Кічук А.В.",
      "Копія картки платника податків Кічук О.С.",
      "Копія довідки про внесення відомостей до єдиного державного демографічного реєстру. №1303026-2023",
      "Копія ID Картки Кічук О.С.",
      "Копія рішення Виконавчого Комітету Таращанської міської ради №305-VIII"
    ];

    let tableDocuments = JSON.parse(localStorage.getItem('tableDocuments')) || [];

    const today = new Date().toISOString().split('T')[0];
    const docBody = document.getElementById('docBody');
    const docList = document.getElementById('docList');
    const editModal = document.getElementById('editModal');
    let currentEditIndex = null;
    let currentEditSource = null;

    function saveDocuments() {
      localStorage.setItem('documents', JSON.stringify(uniqueDocuments));
      localStorage.setItem('tableDocuments', JSON.stringify(getTableData()));
    }

    function getTableData() {
      const rows = [...docBody.querySelectorAll('tr')];
      return rows.map(row => {
        return {
          name: row.children[1].textContent,
          date: row.children[2].querySelector('input').value,
          sheets: row.children[3].querySelector('input').value,
          note: row.children[4].textContent
        };
      });
    }

    function renderList(filteredDocs = uniqueDocuments) {
      docList.innerHTML = '';
      filteredDocs.forEach((doc, index) => {
        const item = document.createElement('div');
        item.classList.add('draggable-item');
        item.textContent = doc;
        item.draggable = true;
        item.dataset.docIndex = index;
        item.addEventListener('dragstart', (e) => {
          e.dataTransfer.setData('text/plain', doc);
          e.dataTransfer.setData('source', 'list');
        });

        const btnContainer = document.createElement('div');
        
        const editBtn = document.createElement('button');
        editBtn.textContent = '✎';
        editBtn.className = 'edit-btn';
        editBtn.onclick = (e) => {
          e.stopPropagation();
          currentEditIndex = index;
          currentEditSource = 'list';
          document.getElementById('editDocName').value = doc;
          editModal.style.display = 'block';
        };

        const delBtn = document.createElement('button');
        delBtn.textContent = '✖';
        delBtn.className = 'delete-btn';
        delBtn.onclick = (e) => {
          e.stopPropagation();
          uniqueDocuments.splice(index, 1);
          saveDocuments();
          renderList();
        };

        btnContainer.appendChild(editBtn);
        btnContainer.appendChild(delBtn);
        item.appendChild(btnContainer);
        docList.appendChild(item);
      });
    }

    function renderTable() {
      docBody.innerHTML = '';
      if (tableDocuments.length > 0) {
        tableDocuments.forEach(doc => {
          addDocumentToTable(doc.name, doc.date, doc.sheets, doc.note);
        });
      }
      updateIndexes();
    }

    function addDocumentToTable(name, date = today, sheets = '1', note = '') {
      const row = document.createElement('tr');
      row.draggable = true;
      row.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('text/plain', name);
        e.dataTransfer.setData('source', 'table');
        row.classList.add('dragging');
      });
      row.addEventListener('dragend', () => row.classList.remove('dragging'));
      row.innerHTML = `
        <td></td>
        <td>${name}</td>
        <td><input type="date" value="${date}"/></td>
        <td><input type="number" value="${sheets}" min="1" style="width: 100%"/></td>
        <td>${note}</td>
        <td>
          <button class="edit-btn" onclick="editTableDocument(this)">✎</button>
          <button class="delete-btn" onclick="this.closest('tr').remove(); updateIndexes(); saveDocuments();">✖</button>
        </td>
      `;
      docBody.appendChild(row);
      updateIndexes();
    }

    function editTableDocument(button) {
      const row = button.closest('tr');
      currentEditIndex = [...docBody.querySelectorAll('tr')].indexOf(row);
      currentEditSource = 'table';
      document.getElementById('editDocName').value = row.children[1].textContent;
      editModal.style.display = 'block';
    }

    function saveEditedDocument() {
      const newName = document.getElementById('editDocName').value.trim();
      if (newName) {
        if (currentEditSource === 'list') {
          uniqueDocuments[currentEditIndex] = newName;
          renderList();
        } else if (currentEditSource === 'table') {
          const rows = [...docBody.querySelectorAll('tr')];
          rows[currentEditIndex].children[1].textContent = newName;
        }
        saveDocuments();
        closeModal();
      }
    }

    function closeModal() {
      editModal.style.display = 'none';
    }

    function handleDrop(e) {
      e.preventDefault();
      const doc = e.dataTransfer.getData('text/plain');
      const source = e.dataTransfer.getData('source');

      if (source === 'table') {
        const dragged = [...docBody.querySelectorAll('tr')].find(r => r.classList.contains('dragging'));
        const dropTarget = e.target.closest('tr');
        if (dragged && dropTarget && dragged !== dropTarget) {
          docBody.insertBefore(dragged, dropTarget.nextSibling);
        }
        updateIndexes();
        saveDocuments();
        return;
      }

      addDocumentToTable(doc);
      saveDocuments();
    }

    function handleRemove(e) {
      e.preventDefault();
      const doc = e.dataTransfer.getData('text/plain');
      const source = e.dataTransfer.getData('source');
      if (source === 'table') {
        const rows = [...docBody.querySelectorAll('tr')];
        const rowToRemove = rows.find(r => r.children[1].textContent === doc);
        if (rowToRemove) rowToRemove.remove();
        updateIndexes();
        saveDocuments();
      }
    }

    function updateIndexes() {
      document.querySelectorAll('#docBody tr').forEach((row, index) => {
        row.children[0].textContent = index + 1;
      });
    }

    function addNewDocument() {
      const newDoc = document.getElementById('newDoc').value.trim();
      if (newDoc) {
        uniqueDocuments.push(newDoc);
        saveDocuments();
        renderList();
        document.getElementById('newDoc').value = '';
      }
    }

    function applyReplace() {
      const replaceFrom = document.getElementById('replaceValueFrom').value.trim();
      const replaceTo = document.getElementById('replaceValueTo').value.trim();
      if (!replaceFrom || !replaceTo) return;
      
      const rows = [...docBody.querySelectorAll('tr')];
      rows.forEach(row => {
        const nameCell = row.children[1];
        nameCell.textContent = nameCell.textContent.replace(new RegExp(replaceFrom, 'g'), replaceTo);
      });
      saveDocuments();
    }

    function applyDateReplace() {
      const replaceDate = document.getElementById('replaceDateValue').value.trim();
      if (!replaceDate) return;

      const rows = [...docBody.querySelectorAll('tr')];
      rows.forEach(row => {
        const dateCell = row.children[2].querySelector('input');
        dateCell.value = replaceDate;
      });
      saveDocuments();
    }

    function searchDocuments() {
      const searchValue = document.getElementById('searchDoc').value.toLowerCase();
      const filteredDocs = uniqueDocuments.filter(doc => doc.toLowerCase().includes(searchValue));
      renderList(filteredDocs);
    }

    function formatDate(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${day}.${month}.${year}`;
    }

    function copyTable() {
      const replaceValue = document.getElementById('replaceValueFrom').value.trim();
      const rows = [...docBody.querySelectorAll('tr')];
      
      let result = '';
      rows.forEach((row, index) => {
        const name = row.children[1].textContent
                          .replace(new RegExp(replaceValue, 'g'), document.getElementById('replaceValueTo').value.trim());
        const date = formatDate(row.children[2].querySelector('input').value);
        const sheets = row.children[3].querySelector('input').value;
        
        result += `${index + 1}.\n${name}\n${date}\n${sheets}\n\n\n`;
      });
      
      navigator.clipboard.writeText(result).then(() => {
        alert("Таблицю скопійовано у потрібному форматі!");
      });
    }

    function exportTable() {
      const format = document.querySelector('input[name="exportFormat"]:checked').value;
      const replaceFrom = document.getElementById('replaceValueFrom').value.trim();
      const replaceTo = document.getElementById('replaceValueTo').value.trim();
      const rows = [...docBody.querySelectorAll('tr')];
      
      let content = '';
      let filename = 'documents_export';
      
      if (format === 'txt') {
        filename += '.txt';
        rows.forEach((row, index) => {
          const name = row.children[1].textContent.replace(new RegExp(replaceFrom, 'g'), replaceTo);
          const date = formatDate(row.children[2].querySelector('input').value);
          const sheets = row.children[3].querySelector('input').value;
          const note = row.children[4].textContent;
          
          content += `${index + 1}.\n${name}\n${date}\n${sheets}\n${note}\n\n\n`;
        });
      } 
      else if (format === 'csv') {
        filename += '.csv';
        content = "№ п/п;Назва документу;Дата включення;К-ть аркушів;Примітка\n";
        rows.forEach((row, index) => {
          const name = row.children[1].textContent.replace(new RegExp(replaceFrom, 'g'), replaceTo);
          const date = formatDate(row.children[2].querySelector('input').value);
          const sheets = row.children[3].querySelector('input').value;
          const note = row.children[4].textContent;
          
          content += `${index + 1};"${name}";${date};${sheets};"${note}"\n`;
        });
      }
      else if (format === 'custom') {
        filename += '.txt';
        const template = document.getElementById('customFormat').value;
        rows.forEach((row, index) => {
          const name = row.children[1].textContent.replace(new RegExp(replaceFrom, 'g'), replaceTo);
          const date = formatDate(row.children[2].querySelector('input').value);
          const sheets = row.children[3].querySelector('input').value;
          const note = row.children[4].textContent;
          
          let rowContent = template
            .replace(/{index}/g, index + 1)
            .replace(/{name}/g, name)
            .replace(/{date}/g, date)
            .replace(/{sheets}/g, sheets)
            .replace(/{note}/g, note);
            
          content += rowContent;
        });
      }
      
      // Создаем Blob и ссылку для скачивания
      const blob = new Blob([content], { type: format === 'csv' ? 'text/csv;charset=utf-8;' : 'text/plain;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      
      link.setAttribute('href', url);
      link.setAttribute('download', filename);
      link.style.visibility = 'hidden';
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // ==== HTML TABLE COPY FUNCTION =====
    function copyTableHtmlToClipboard() {
      const rows = [...document.querySelectorAll('#docBody tr')];
      if (!rows.length) {
        alert('Таблиця порожня!');
        return;
      }
      let html = `<table style="border-collapse:collapse;background:#fff;font-family:'Times New Roman',Times,serif;width:100%;">`;

      // Заголовок
      html += `<tr>
        <td style="border:0.5pt solid #000;padding:5pt;">№ п/п</td>
        <td style="border:0.5pt solid #000;padding:5pt;">Назва документу</td>
        <td style="border:0.5pt solid #000;padding:5pt;">Дата включення</td>
        <td style="border:0.5pt solid #000;padding:5pt;">К-ть аркушів</td>
        <td style="border:0.5pt solid #000;padding:5pt;">Примітка</td>
      </tr>`;

      // Данные строк
      rows.forEach((row, idx) => {
        const name = row.children[1].textContent;
        const date = formatDate(row.children[2].querySelector('input').value);
        const sheets = row.children[3].querySelector('input').value;
        const note = row.children[4].textContent;
        html += `<tr>
          <td style="border:0.5pt solid #000;padding:5pt;">${idx + 1}</td>
          <td style="border:0.5pt solid #000;padding:5pt;">${name}</td>
          <td style="border:0.5pt solid #000;padding:5pt;">${date}</td>
          <td style="border:0.5pt solid #000;padding:5pt;">${sheets}</td>
          <td style="border:0.5pt solid #000;padding:5pt;">${note}</td>
        </tr>`;
      });
      html += `</table>`;

      // Копируем как HTML в буфер обмена
      if (navigator.clipboard && window.ClipboardItem) {
        const blob = new Blob([html], { type: "text/html" });
        const data = [new ClipboardItem({ "text/html": blob })];
        navigator.clipboard.write(data).then(() => {
          alert("HTML-таблиця скопійована! Вставте її у Word або Google Docs.");
        }, () => {
          alert("Помилка при копіюванні!");
        });
      } else {
        // Фолбэк для старых браузеров
        const textarea = document.createElement('textarea');
        textarea.value = html;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        alert('HTML-код скопійовано як текст.');
      }
    }
    // ==== END HTML TABLE COPY FUNCTION ====

    window.addEventListener('DOMContentLoaded', () => {
      renderList();
      renderTable();
    });

    window.onclick = function(event) {
      if (event.target == editModal) {
        closeModal();
      }
    }
  </script>
</body>
</html>
